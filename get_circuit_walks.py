import networkx as nx
import numpy as np
import pandas as pd
import cyc_circs as cc
import seq_circs as sc
import sys as sys


'''
The below function constraint_matrix builds a matrix B, which is the constraint matrix for the transportation polytope.
Input: number of nodes and number of clusters for a given transportation problem
Output: constraint matrix of the transportation problem
'''

def constraint_matrix(num_nodes,num_clusters):
	B=np.zeros((num_nodes+num_clusters+num_nodes*num_clusters,num_nodes*num_clusters))
	for i in range(num_nodes):
                for j in range(num_clusters):
                        B[i,j+i*num_clusters]=1
	for i in range(num_clusters):
                for j in range(num_nodes):
                        B[i+num_nodes,j*num_clusters+i]=1
	for i in range(num_nodes*num_clusters):
               B[i+num_nodes+num_clusters,i] = -1
	return B


'''
The below function below creates a sign-compatible circuit walk
Input: an current or starting vertex, an ideal or ending vertex, a set of all circuits, and constraint matrix B.
Output: a set of circuits that create a sign-compatible circuit walk from the current vertex to the ideal
'''
def circuit_walk(vert1,vert2, circuits,B):
	s = vert1
	u = vert2-s
	circuit_set = []
	already_picked = []
	lamb = []
	g = 0
	count=0
	#print('B mat',B)
	while (any(s != vert2)):
		for i in circuits[count:]:
			count += 1
			if count == len(circuits):
				print('too many circuits bitch')
				sys.exit('you suck')
			#makes sure we didn't already pick that circuit, and checks sign compatibility
			if list(i) not in already_picked:
				Bu_float = B.dot(u)
				#Bg = B.dot(i)
				Bg_float = B.dot(np.array(np.transpose(np.array(i))))
				Bu = list(Bu_float.astype(np.int32))
				Bg = list(Bg_float.astype(np.int32))
				sc_check1 = list(filter(lambda c: c < 0, (np.transpose(Bu)*Bg)))
				sc_check2 = list(filter(lambda c: c < 0, (np.transpose(u)*np.transpose(np.array(i)))))
				sc_check = sc_check1+sc_check2
				#if we are sign compatible, then we make sure that we are getting closer to our ideal state in at least one place 
				if not sc_check:
					vertex_zeros = set(np.where(np.array(Bu) == 0)[0])
					g_zeros = set(np.where(np.array(Bg) == 0)[0])
					if vertex_zeros.issubset(g_zeros):
						g=i
						already_picked.append(list(g))
						print('already picked', already_picked)
						break
		#computes the minimal lambda for each non-zero entry of our circuit g.
		for i in range(len(g)):
			if g[i] != 0:
				weight=(vert2[i]-s[i])/g[i]
				lamb.append(weight)

		print('g:', g)
		print('s:', s)
		print('u:', u)
		print('ideal state:', vert2)

		pos_lamb = list(filter(lambda c: c > 0, lamb))
		min_lambda = min(pos_lamb)
		print('lambda picked', min_lambda)
		s = s+(min_lambda*g)
		u = vert2-s
		circuit_set.append(list(min_lambda*g))
		lamb = []
		print(circuit_set)
	print('circ_walk finished')
	return circuit_set


'''
Should have really made something that changed these based on input so that it didn't have to be done manually
'''
clusters=13
nodes=2

'''
Reads in start state from csv and reshapes it into a 26x1 vector
'''
raw_start_data = np.array(pd.read_csv('start_animals_.csv', header = 0))
start_vert_=np.reshape(raw_start_data,(1,nodes*clusters))
start_vert=start_vert_[0]

'''
ideal vertex below was generated by ordering the shelters from highest adoption rate to lowest, and then assigning as many dogs and puppies as we can to the shelters with the most demand. We treated puppy capacity and adult capacity as two separate capacities.
'''
ideal_vert=np.array([48,0,6,0,108,39,199,34,3,6,228,30,0,74,50,111,86,380,215,261,86,49,27,4008,0,0])

'''
ideal vertex below was generated by ordering the shelters from highest adoption rate to lowest, and then assigning as many dogs as we can to the shelters with the most demand. Then we assign as many puppies as we can to the shelters with the most demand that are not already full..
'''
#ideal_vert=np.array([48,6,39,354,46,0,0,199,3,6,0,0,0,74,27,215,4674,111,50,86,110,0,0,0,0,0])



print(sum(ideal_vert))
print(sum(start_vert))
print(ideal_vert)
print(start_vert)


'''
ideal_state_vertex and current_state_vertex are made so that they can create an ideal and current state for partition polytope(not transportation) given a csv with cluster_capacity and intake_amount
'''

'''
def ideal_state_vertex(nodes,clusters,cluster_capacity):
	k=0
	temp_nodes=sum(cluster_capacity)
	ideal_state=np.zeros((temp_nodes,clusters))
	for i in range(clusters):
		for j in range(cluster_capacity[i]):
			ideal_state[k+j,i]=1
		k=j+1+k
	ideal_state=ideal_state[0:nodes]
	return ideal_state
ideal_state=ideal_state_vertex(nodes,clusters,cluster_capacity)
print(ideal_state)
'''
'''
def current_state_vertex(nodes,clusters,intake_amount,cluster_capacity):
	k=0
	temp_nodes=sum(cluster_capacity)
	start_state=np.zeros((temp_nodes,clusters))
	for i in range(clusters):
		for j in range(intake_amount[i]):
			start_state[k+j,i]=1
		k=j+k+1
	start_state=start_state[0:nodes]
	return start_state
'''


B=constraint_matrix(nodes,clusters)
print(B)
seqCircs=sc.sequential_circuits(nodes,clusters)
cyCircs=cc.cycle_circuits(nodes,clusters)

'''this part existed because I was troubleshooting, but it changed the order the circuits were picked in, so you need to comment out the circuits line below all this and uncomment all this to get the same circuit walk as in the presentation'''
#circuits_ = cyCircs + seqCircs
#circuits_set = set(map(tuple,circuits_))
#circuits_dup_rem=list(circuits_set)
#circuits_float=np.array([list(ele) for ele in circuits_dup_rem])
#circuits=circuits_float.astype(np.int)

circuits=cyCircs+seqCircs
print(circuit_walk(start_vert,ideal_vert,circuits,B))

